<!doctype html>
<html lang="en">
  <head>
	<title>Seven Transistor Laboratories, LLC: Font Encoder</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name=viewport content="width=device-width, initial-scale=1">
	<style media=all><!--

body {
	font-family: Verdana, Arial, sans-serif;
	line-height: 130%;
}

h1 {
	text-align: center;
	line-height: 130%;
}

canvas {
	border: 1px solid #404040;
}

p.fig {
	margin-left: auto;
	margin-right: auto;
}

p.messagebox {
	color: #e00000;
}

span.tt {
	font-family: Consolas, Courier, monospace;
	background-color: #ececec;
}

li {
	padding-bottom: 0.25em;
}

div {
	padding-bottom: 0.5em;
	margin-left: 5%;
	margin-right: 10%;
}

div.div {
	margin: 0%;
}

div.inl {
	display: inline;
	margin-left: 0%;
	margin-right: 0%;
}

div.options {
	line-height: 150%;
}

pre {
	line-height: 115%;
	background-color: #f8f8f8;
	color: #606060;
	border: solid 1px #000000;
	padding: 2px;
}

pre.code {
	max-width: 70em;
	height: 30em;
	overflow: scroll;
}

pre.ex {
	margin-left: 5%;
	margin-right: 5%;
}

input[type=file] {
	border: 1px solid #404040;
	padding: 4px;
}

input[type=button] {
	margin-top: 0.5em;
}

input[type=text] {
	width: 10em;
}

input[type=number] {
	width: 6em;
}

table {
	width: 100%;
}

	--></style>
  </head>
  <body>
	<h1>Bitmap Font Encoder</h1>
	<div class="inputs">
	  <p>Enter a file here:</p>
	  <input type="file" id="filein">
	  <input type="button" value="Submit" id="submit">
	  <p class="messagebox" id="messagebox"></p>
	</div>
	<div class="graphics">
	  <h2>Input Data</h2>
	  <canvas width="100" height="100" id="image">Select an Image</canvas>
	  <p id="inputmessage"></p>
	  <p class="messagebox" id="inputwarning"></p>
	</div>
	<div class="options">
	  <h2>Output Data</h2>
	  <table><tbody><tr>
		<td>
		  Encoder:
		  <div id="codecselect">
			<label><input type="radio" name="encodertype" checked>Enable Javascript</label><br>
<!--			<label><input type="radio" name="encodertype">Packed Nibbles</label><br>
			<label><input type="radio" name="encodertype">(1, 2, 6) Huffman Code</label><br>
			<label><input type="radio" name="encodertype">Arithmetic Code, DWORDs</label><br>
			<label><input type="radio" name="encodertype">Arithmetic Code, Stream, Fixed Model</label><br>
			<label><input type="radio" name="encodertype">Arithmetic Code, Stream, Adaptive Model</label><br>
			<label><input type="radio" name="encodertype">Run Length Encoder</label><br>
			<label><input type="radio" name="encodertype">Dictionary Coding</label><br>
-->
		  </div>
		  Direction and Grouping:
		  <div>
			<label><input type="radio" name="encoderows" checked>Individual Rows</label><br>
			<label><input type="radio" name="encoderows">Blocks, Row First</label><br>
			<label><input type="radio" name="encoderows">Blocks, Column First</label>
		  </div>
		</td><td>
		  Metadata:
		  <div>
			<label><input type="checkbox" id="packwidths" checked>Pack Widths if Possible</label><br>
			<label><input type="checkbox" id="packlengths" checked>Pack Lengths if Possible</label><br>
		  </div>
		  <br>Output Format:
		  <div>
			<label><input type="radio" name="outputtype" checked>Verbose (Text)</label><br>
			<label><input type="radio" name="outputtype">C Header</label><br>
			<label><input type="radio" name="outputtype">Binary</label><br>
		  </div>
		  <div><label>File name: <input type="text" id="filenamebox"></label></div>
		</td>
	  </tr></tbody></table>
	</div>
	<div class="outputs">
	  <p id="outputmessage"></p>
	  <pre class="code" id="output"></pre>
	  <input type="button" value="Download" id="download" disabled>
	  <table><tbody>
		<tr><td style="padding-top: 2ex;">Decoded result:</td></tr>
		<tr><td><canvas width="100" height="100" id="decoded">Decoded Image</canvas></td></tr>
		<tr><td style="padding-top: 1ex;">Inspect Characters:</td></tr>
		<tr><td><canvas width="100" height="100" id="character">Character</canvas></td></tr>
		<tr><td>
		  <table style="width: auto;"><tbody>
			<tr><td style="text-align: right"><label for="characterbox">Index:</label></td><td style="text-align: left">
		<input type="number" id="characterbox" min="0" max="1" step="1" value="0"></td></tr>
			<tr><td style="text-align: right"><label for="characterzoom">Scale:</label></td><td style="text-align: left"><input type="number" id="characterzoom" min="1" max="16" step="1" value="8"></td></tr>
		  </tbody></table>
		</td></tr>
	  </tbody></table>
	</div>
	<div class="comments">
	  <h2>Input File Format</h2>
	  <p>A 2 to 17-color image, containing all the desired glyphs, each with a fiducial marking its width.  An example, Lucidia Sans 10pt, characters 32 to 127:</p>
	  <p class="fig"><img src="FontLucidia.png" alt="Example Font" width="561" height="11"></p>
	  <p class="fig">
		<img src="FontGuide1.png" alt="Character Details" width="296" height="419"> &nbsp; &nbsp;
		<img src="FontGuide2.png" alt="Ending Detail" width="307" height="220">
	  </p>
	  <p>The left edge of the image is discarded, up to the first fiducial, which marks the zeroth column of the zeroth character.  The next fiducial marks the zeroth column of the next character, and so on.  Image height is taken as character height, uniform for the whole font.  Make sure to crop the image so that no ascenders or descenders are accidentally cut off&mdash;few letters use the full box, check carefully!</p>
	  <p>The fiducial is always <span class="tt" id="colorvalue">#ff0000</span> (<span id="colorname">red</span>).  It is translated to white (<span class="tt">#ffffff</span>).  The vertical position of the fiducial doesn't matter, nor the number of pixels in the column colored that way.  (TODO: make some way to encode grayscale under the fiducial?)  All other colors: the average ((R + G + B) / 3) is used.  Alpha is not used.  Output is up to 16 shades of grayscale.</p>
	  <h2>Output File Format</h2>
	  <ul>
		<li>TBD</li>
	  </ul>
	  <h2>Options, Notes</h2>
	  <p><b>Text format:</b> Includes statistics on font metrics, encoding efficiency (compression), etc.</p>
	  <p><b>C header format:</b> Header contents are <span class="tt">#define</span>d.  All BYTEs are uint8_t, WORDs are uint16_t, etc.</p>
	  <p>Only the header is given above; the accompanying C code to use it is as follows (as an avr-gcc ROM declaration):</p>
<pre class="ex">
#include "Header_Name.h"

#ifdef HEADER_NAME_H_INCLUDED
//  Place this at the top, or in the common header file:
const uint8_t ImageData[HEADER_NAME_TOTAL_LEN];

//  Reference this with: drawImage(ImageData, x, y);
const uint8_t ImageData[] PROGMEM = {
	(HEADER_NAME_PALETTE_LEN & 0x00ff),
	HEADER_NAME_PAL,
	HEADER_NAME_CMDS
};
#endif // HEADER_NAME_H_INCLUDED
</pre>
	  <p><b>Execution speed:</b> Graphics writes tend to dominate, particularly via serial (SPI or other).  For display controllers with a set-draw-window command having single pixel resolution, whole characters can be drawn at a time, without too much overhead (one window command per character).  If the window can be filled in vertical columns, one window command for a whole line of characters may even do.  If pixels can only be written row-wise, then characters also must be drawn a row at a time, and the font has to be encoded by rows rather than blocks.</p>
	  <p><b>Compression/Encoding:</b> .</p>
	  <h2>Future Improvements, Speculation</h2>
	  <p>Foo?</p>
	</div>
	<script src="FileSaver.min.js"></script>
	<script><!--

/*
 *	Data passed from processFile() to setOutputData() to viewChar() and downloadOutput()
 */

/**	Loaded image data, in row-major array format, 32-bit RGB  */
var imgArray;
/**	Loaded image width and height  */
var imgWidth, imgHeight;
/**	Decoded image data for viewChar  */
var decodedData;
/**	Output data  */
var binaryOutput;

/**	Filename of the source image  */
var fileName = '';

/*
 *	Constants
 */

const MIN_COLORS	= 3;			//	Minimum number of colors: needs at least black, white and fid
const MAX_COLORS	= 17;			//	Warning threshold
const ERR_COLORS	= 256;			//	Number of colors to fault out immediately
const FID_COLOR		= 0x0000ff;		//	Fiducial mark, hex value
const FID_VALUE		= '#ff0000';	//	Fiducial mark, HTML value (also used to update HTML text)
const FID_NAME		= 'red';		//	Fiducial mark, English name (also used to update HTML text)

document.getElementById('submit').addEventListener('click', processFile, true);
document.getElementById('download').addEventListener('click', downloadOutput, true);
document.getElementsByName('encoderows').forEach(n => n.addEventListener('click', setOutputData, true));
document.getElementsByName('outputtype').forEach(n => n.addEventListener('click', setOutputData, true));
document.getElementById('packwidths').addEventListener('click', setOutputData, true);
document.getElementById('packlengths').addEventListener('click', setOutputData, true);
document.getElementById('filenamebox').addEventListener('change', setOutputData, true);
document.getElementById('colorvalue').innerHTML = FID_VALUE;
document.getElementById('colorname').innerHTML = FID_NAME;
document.getElementById('characterbox').addEventListener('change', viewChar, true);
document.getElementById('characterzoom').addEventListener('change', viewChar, true);

document.addEventListener('DOMContentLoaded', function() {
	var d = document.getElementById('codecselect');
	d.innerHTML = '';
	for (var i = 0; i < ALL_CODECS.length; i++) {
		var e = document.createElement('label');
		e.appendChild(document.createElement('input'));
		e.appendChild(document.createTextNode(ALL_CODECS[i].name));
		e.appendChild(document.createElement('br'));
		e.children[0].type = 'radio';
		e.children[0].name = 'encodertype';
		if (i == 0) e.children[0].checked = true;
		e.children[0].addEventListener('click', setOutputData, true);
		d.appendChild(e);
	}
}, true);


function processFile() {
	var f = document.getElementById('filein').files;
	if (f.length != 1) {
		document.getElementById('messagebox').innerHTML = 'Please select a single image file.';
		return;
	}
	fileName = f[0].name;

	document.getElementById('messagebox').innerHTML = '';
	imgArray = null;
	var fr = new FileReader();
	fr.onload = function () {
		clearHTML();
		var img = new Image();
		img.addEventListener('error', function () {
			document.getElementById('messagebox').innerHTML = 'Error loading image.';
		});
		img.addEventListener('load', function () {
			var f = fileName.substr(0, fileName.lastIndexOf('.')) || fileName;
			if (document.getElementsByName('outputtype')[0].checked) {
				f += '.txt';
			} else if (document.getElementsByName('outputtype')[1].checked) {
				f += '.h';
			} else {	//	if (document.getElementsByName('outputtype')[2].checked)
				f += '.bin';
			}
			document.getElementById('filenamebox').value = f;

			var ctx = document.getElementById('image').getContext('2d');
			imgWidth = img.naturalWidth; imgHeight = img.naturalHeight;
			ctx.canvas.width = imgWidth; ctx.canvas.height = imgHeight;
			ctx.drawImage(img, 0, 0);
			imgArray = new Uint32Array(imgWidth * imgHeight);
			var imgD = ctx.getImageData(0, 0, imgWidth, imgHeight).data;
			for (var i = 0; i < imgWidth * imgHeight; i++) {
				imgArray[i] = imgD[i * 4] + 256 * (imgD[i * 4 + 1] + imgD[i * 4 + 2] * 256);
			}

/*			//	To test image loading
			document.getElementById('output').innerHTML = 'width: ' + imgWidth
					+ ', height: ' + imgHeight + ', data:\n\n' + Array.from(
					imgArray, function (x) {
						return '0x' + (x & 0x00ffffff).toString(16);
					}).join(', ');
*/
			window.setTimeout(setOutputData, 10);
		});
		img.src = fr.result;
	}
	fr.readAsDataURL(f[0]);
}

function setOutputData() {

	/*
	 *	Process the image:
	 *		Count number of colors
	 *		Detect fiducials
	 *		Convert colors to grayscale (convert fiducials to white)
	 */

	/**	Local copy of imgArray for processing  */
	var imgData = new Uint8Array(imgWidth * imgHeight);
	var colors = new Map();
	var total = 0;
	var box;
	var charStarts = [], charWidths = [];

	if (!imgArray || imgArray.length == 0) {
		document.getElementById('outputmessage').innerHTML = '';
		return;
	}
	document.getElementById('inputmessage').innerHTML = 'Width: ' + imgWidth + ', Height: ' + imgHeight;
	document.getElementById('inputwarning').innerHTML = '';

	for (var x = 0; x < imgWidth; x++) {

		var fid = false;

		for (var y = 0; y < imgHeight; y++) {

			//	Detect fiducials, translate to white pixels
			if (imgArray[x + y * imgWidth] == FID_COLOR) {
				imgData[x + y * imgWidth] = (255 << 16) + (255 << 8) + 255;
				fid = true;
			} else {
				//	Convert to grayscale (average channels)
				imgData[x + y * imgWidth] = Math.floor( (
						   (imgArray[x + y * imgWidth] & 0xff)
						+ ((imgArray[x + y * imgWidth] >>> 8) & 0xff)
						+ ((imgArray[x + y * imgWidth] >>> 16) & 0xff)
						) / 3);
			}

			var o = colors.get(imgData[x + y * imgWidth]);
			if (o === undefined) {
				colors.set(imgData[x + y * imgWidth], 1);
				total++;
			} else {
				colors.set(imgData[x + y * imgWidth], o + 1);
			}
			if (total >= ERR_COLORS) {
				document.getElementById('inputmessage').innerHTML += '<br>\nNumber of colors: &gt;' + total;
				document.getElementById('inputwarning').innerHTML = 'Error: more than ' + ERR_COLORS + ' colors present!';
				return;
			}

		}

		if (fid) {
			//	Found a fiducial on this column
			charStarts.push(x);
			if (charStarts.length > 1)
				charWidths.push(x - charStarts[charStarts.length - 2]);
		}

	}
	charWidths.push(imgWidth - charStarts[charStarts.length - 1]);

	document.getElementById('inputmessage').innerHTML += '<br>\nNumber of colors: ' + total;
	if (total > MAX_COLORS) {
		document.getElementById('inputwarning').innerHTML = 'Warning: more than ' + MAX_COLORS + ' colors present.<br>\n';
	}
	if (total < MIN_COLORS) {
		document.getElementById('inputwarning').innerHTML = 'Warning: not enough colors present.<br>\n';
	}
	if (charStarts.length < 1) {
		document.getElementById('inputwarning').innerHTML += 'Warning: no ' + FID_NAME + ' (' + FID_VALUE + ') markers found.<br>\n';
	}

	/*
	 *	Sort the colors into a palette; map image data to the new palette
	 */
	var palette = [];
	for (var c of colors) {
		palette.push({ val: c[0], freq: c[1] });
	}
	palette.sort((a, b) => {return a.val - b.val});
	{
		var indexes = new Uint8Array(256);
		for (var i = 0; i < palette.length; i++) {
			indexes[palette[i].val] = i;
		}
		for (var i = 0; i < imgWidth * imgHeight; i++) {
			imgData[i] = indexes[imgData[i]];
		}
	}

/*
 *
 *	Encode Characters
 *
 */

	//	Select codec
	var codec;
	for (var radios = document.getElementsByName('encodertype'), i = 0; i < radios.length; i++) {
		if (radios[i].checked) {
			codec = ALL_CODECS[i];
			break;
		}
	}

	var encodedChars = [];
	var encoderState = new Object();
	if (codec.encodeInit)
		codec.encodeInit(encoderState, palette);

	if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows

		for (var y = 0; y < imgHeight; y++) {
			encodedChars.push([]);
			for (var i = 0; i < charStarts.length; i++) {
				encodedChars[y].push([]);
				codec.encodeStart(encoderState, palette);
				for (var x = 0; x < charWidths[i]; x++) {
					codec.encodeStep(imgData[x + charStarts[i] + y * imgWidth], encoderState, encodedChars[y][i]);
				}
				codec.encodeEnd(encoderState, encodedChars[y][i]);
			}
		}

	} else if (document.getElementsByName('encoderows')[1].checked) {	//	Blocks, row first

		for (var i = 0; i < charStarts.length; i++) {
			encodedChars.push([]);
			codec.encodeStart(encoderState, palette);
			for (var y = 0; y < imgHeight; y++) {
				for (var x = 0; x < charWidths[i]; x++) {
					codec.encodeStep(imgData[x + charStarts[i] + y * imgWidth], encoderState, encodedChars[i]);
				}
			}
			codec.encodeEnd(encoderState, encodedChars[i]);
		}

	} else {	//	Blocks, column first

		for (var i = 0; i < charStarts.length; i++) {
			encodedChars.push([]);
			codec.encodeStart(encoderState, palette);
			for (var x = 0; x < charWidths[i]; x++) {
				for (var y = 0; y < imgHeight; y++) {
					codec.encodeStep(imgData[x + charStarts[i] + y * imgWidth], encoderState, encodedChars[i]);
				}
			}
			codec.encodeEnd(encoderState, encodedChars[i]);
		}

	}
	if (codec.encodeFinal) {
		encodedChars.header = codec.encodeFinal(encoderState);
	}

/*
 *
 *	Decode result and show on output canvas
 *
 */

	var decodeWidth = 0;
	charWidths.forEach(x => (decodeWidth += x));
	var img = new Uint8ClampedArray(4 * decodeWidth * imgHeight);
	var encoderState = new Object();
	if (codec.decodeInit)
		codec.decodeInit(encoderState, encodedChars.header);

	if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows

		for (var y = 0; y < imgHeight; y++) {
			for (var i = 0; i < charStarts.length; i++) {
				codec.decodeStart(encoderState, encodedChars.header);
				var iter = encodedChars[y][i].entries();
				for (var x = 0; x < charWidths[i]; x++) {
					var d = codec.decodeStep(iter, encoderState);
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 0] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 1] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 2] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 3] = 255;
				}
			}
		}

	} else if (document.getElementsByName('encoderows')[1].checked) {	//	Blocks, row first

		for (var i = 0; i < charStarts.length; i++) {
			codec.decodeStart(encoderState, encodedChars.header);
			var iter = encodedChars[i].entries();
			for (var y = 0; y < imgHeight; y++) {
				for (var x = 0; x < charWidths[i]; x++) {
					var d = codec.decodeStep(iter, encoderState);
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 0] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 1] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 2] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 3] = 255;
				}
			}
		}

	} else {	//	Blocks, column first

		for (var i = 0; i < charStarts.length; i++) {
			codec.decodeStart(encoderState, encodedChars.header);
			var iter = encodedChars[i].entries();
			for (var x = 0; x < charWidths[i]; x++) {
				for (var y = 0; y < imgHeight; y++) {
					var d = codec.decodeStep(iter, encoderState);
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 0] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 1] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 2] = palette[d].val;
					img[4 * (y * decodeWidth + x + charStarts[i] - charStarts[0]) + 3] = 255;
				}
			}
		}
	}

	var ctx = document.getElementById('decoded');
	ctx.width = decodeWidth; ctx.height = imgHeight;
	ctx = ctx.getContext('2d');
	ctx.putImageData(new ImageData(img, decodeWidth, imgHeight), 0, 0);
	decodedData = {
		data: img,
		widths: charWidths,
		totalWidth: decodeWidth,
		height: imgHeight
	};

/*
 *
 *	Generate Outputs
 *
 */

	var f = document.getElementById('filenamebox').value;
	f = f.substr(0, f.lastIndexOf('.')) || f;

	var charLengths = [];
	if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows
		for (var i = 0; i < encodedChars.length; i++) {
			charLengths.push([]);
			for (var j = 0; j < encodedChars[i].length; j++) {
				charLengths[i].push(encodedChars[i][j].length);
			}
		}
	} else {	//	Blocks
		for (var i = 0; i < encodedChars.length; i++) {
			charLengths.push(encodedChars[i].length);
		}
	}

	var widthCharsBpp = 8, lengthCharsBpp = 8;
	box = '';
	//	Check if packing is possible
	var l = 0, j = 0;
	for (var i = 0; i < charWidths.length; i++) {
		if (charWidths[i] > l) {
			l = charWidths[i]; j = i;
		}
	}
	box += 'Widest character: ' + l + ' pixels, index: ' + j + '<br>\n';
	if (l < 16 && document.getElementById('packwidths').checked) {
		box += 'Packing nibbles<br>\n';
		widthCharsBpp = 4;
	} else if (l < 256 && document.getElementById('packwidths').checked) {
		box += 'Too wide to pack nibbles<br>\n';
	} if (l >= 256) {
		box += 'Error: maximum character width exceeds byte size<br>\n';
	}
	l = 0; j = 0;
	if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows
		var n = 0;
		for (var i = 0; i < charLengths.length; i++) {
			for (var k = 0; k < charLengths[i].length; k++) {
				if (charLengths[i][k] > l) {
					l = charLengths[i][k]; j = k; n = i;
				}
			}
		}
		box += 'Longest character data: ' + l + ' bytes, index: ' + j + ', row: ' + n + '<br>\n';
	} else {	//	blocks
		for (var i = 0; i < charWidths.length; i++) {
			if (charLengths[i] > l) {
				l = charLengths[i]; j = i;
			}
		}
		box += 'Longest character data: ' + l + ' bytes, index: ' + j + '<br>\n';
	}
	if (l < 16 && document.getElementById('packlengths').checked) {
		box += 'Packing nibbles<br>\n';
		lengthCharsBpp = 4;
	} else if (l < 256 && document.getElementById('packlengths').checked) {
		box += 'Too long to pack nibbles<br>\n';
	}
	if (l >= 256) {
		box += 'Error: maximum character data exceeds byte size<br>\n';
	}
	document.getElementById('outputmessage').innerHTML = box;

/*
 *
 * Verbose (Text)
 *
 */

	if (document.getElementsByName('outputtype')[0].checked) {
		f += '.txt';

		box = 'Encoder ID: 0x' + codec.id.toString(16) + ', name: ' + codec.name + '\n';
		box += 'Palette entries: ' + palette.length + '\n';
		box += 'Palette values:\n';
		for (var i of palette) {
			box += i.val + ', ';
		}
		box = box.slice(0, box.length - 2) + '\n';
		box += 'Palette occurrences:\n';
		for (var i of palette) {
			box += i.freq + ', ';
		}
		box = box.slice(0, box.length - 2) + '\n';

		var e = 0;
		for (var i of palette) {
			e -= i.freq / (imgWidth * imgHeight) * Math.log(i.freq / (imgWidth * imgHeight)) / Math.LN2;
		}
		box += 'Entropy: ' + e.toString().substr(0, 5) + ' bits/pixel\n\n';

		box += 'Font height: ' + imgHeight + '\n';
		box += 'Characters: ' + charStarts.length + '\n';
		box += 'Character widths:\n';
		for (var i of charWidths) {
			box += i + ', ';
		}
		box = box.slice(0, box.length - 2) + '\n\n';

		box += 'Encoded data:\n';
		box += 'Total length: ' + ((encodedChars.header ? encodedChars.header.length : 0)
				+ arrTreeCount(encodedChars)) + ' bytes\n';
		if (encodedChars.header) {
			box += 'Header: ';
			for (var i = 0; i < encodedChars.header.length; i++) {
				box += byteToHex(encodedChars.header[i]) + ', ';
			}
			box = box.slice(0, box.length - 2) + '\nData:\n';
		}
		for (var i = 0; i < encodedChars.length; i++) {
			if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows
				box += 'Row ' + i + ': ';
				for (var j = 0; j < encodedChars[i].length; j++) {
					box += 'char ' + j + ': ';
					for (var k = 0; k < encodedChars[i][j].length; k++) {
						box += byteToHex(encodedChars[i][j][k]) + ', ';
					}
					if (encodedChars[i][j].length)
						box = box.slice(0, box.length - 2);
					box += '; ';
				}
				box = box.slice(0, box.length - 2) + '\n';
			} else {	//	blocks
				box += 'Char ' + i + ': ';
				for (var j = 0; j < encodedChars[i].length; j++) {
					box += byteToHex(encodedChars[i][j]) + ', ';
				}
				if (encodedChars[i].length)
					box = box.slice(0, box.length - 2);
				box += '\n';
			}
		}


/*
 *
 * C Header
 *
 */

	} else if (document.getElementsByName('outputtype')[1].checked) {
		f += '.h';

		var defName = f.substr(0, f.lastIndexOf('.')) || f;
		//	Replace non-identifier characters (sorry Unicode users)
		defName = defName.replace(/^[^a-zA-Z_]/, '_').replace(/[^A-Za-z0-9_]/g, '_').toUpperCase();

		box =	  '/*\n'
				+ ' *  Compressed Font Data\n'
				+ ' *  Encoder by Tim Williams, 2020-11-19\n'
				+ ' *  Original: ' + fileName + '\n'
				+ ' *  Encoded on: ' + new Date() + '\n'
				+ ' */\n'
				+ '\n'
				+ '#ifndef ' + defName + '_H_INCLUDED\n'
				+ '#define ' + defName + '_H_INCLUDED\n'
				+ '\n'
				+ '#define ' + defName + '_ENCODER_ID\t0x' + (codec.id).toString(16)
						+ '\t\t/*  Encoder: ' + codec.name + '  */\n'
				+ '#define ' + defName + '_HEIGHT\t\t' + imgHeight + '\n'
				+ '#define ' + defName + '_START_CODE\t\t0\t/*  ASCII code at offset 0  */\n'
				+ '#define ' + defName + '_END_CODE\t\t' + defName + '_START_CODE + '
						+ (charWidths.length - 1) + '\t/*  ASCII code at ending offset  */\n'
				+ '#define ' + defName + '_PALETTE_SIZE\t\t'
						+ palette.length + '\t/*  Size of grayscale palette data  */\n';

		box += '#define ' + defName + '_WIDTHS_SIZE\t\t';
		if (widthCharsBpp == 4) {			//	4-bit packed
			box += '((2 + ' + defName + '_END_CODE - ' + defName + '_START_CODE) / 2)';
		} else if (widthCharsBpp == 8) {	//	unpacked bytes
			box += '(1 + ' + defName + '_END_CODE - ' + defName + '_START_CODE)';
		} else {	//	???
			box += '/*  Unsupported data width  */';
		}
		box += '\t/*  Size of array of character widths  */\n';
		if (widthCharsBpp == 4) {
			box += '#define ' + defName + '_WIDTHS_PACKED\n';
		}

		box += '#define ' + defName + '_LENGTHS_SIZE\t\t';
		if (lengthCharsBpp == 4) {			//	4-bit packed
			box += '((2 + ' + defName + '_END_CODE - ' + defName + '_START_CODE) / 2)';
		} else if (lengthCharsBpp == 8) {	//	unpacked bytes
			box += '(1 + ' + defName + '_END_CODE - ' + defName + '_START_CODE)';
		} else {	//	???
			box += '/*  Unsupported data width  */';
		}
		box += '\t/*  Size of array(s) of data lengths  */\n';
		if (lengthCharsBpp == 4) {
			box += '#define ' + defName + '_LENGTHS_PACKED\n\n';
		}

		if (encodedChars.header) {
			box += '#define ' + defName + '_HEADER_SIZE\t\t'
					+ (encodedChars.header.length)
					+ '\t/*  Size of font header block  */\n';
		}

		box += '#define ' + defName + '_DATA_SIZE\t\t'
				+ arrTreeCount(encodedChars)
				+ '\t/*  Size of encoded font data  */\n\n';

		if (encodedChars.header) {
			box += '#define ' + defName + '_HEADER' + '\t';
			box += arrTreeToString(encodedChars.header);
			box += '\n\n';
		}

		//	Palette is in a different format (array of objects) so just do this one by hand
		box += '#define ' + defName + '_PALETTE\t';
		var j = 0;
		for (var i of palette) {
			if ((j++) % 8 == 0) {
				box += '\t\\\n\t';
			}
			box += byteToHex(i.val) + ', ';
		}
		box = box.slice(0, box.length - 2) + '\n\n';

		box += '#define ' + defName + '_CHAR_WIDTHS\t';
		if (widthCharsBpp == 4) {
			//	4-bit packed
			box += arrTreeToString(packNibbles(charWidths));
		} else if (widthCharsBpp == 8) {
			//	unpacked bytes
			box += arrTreeToString(charWidths);
		} else {
			//	???
			box += '/*  Unsupported data width  */';
		}
		box += '\n\n';

		if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows
			for (var i = 0; i < encodedChars.length; i++) {
				box += '#define ' + defName + '_DATA_LENGTHS' + i + '\t';
				if (lengthCharsBpp == 4) {
					//	4-bit packed
					box += arrTreeToString(packNibbles(charLengths[i]));
				} else if (lengthCharsBpp == 8) {
					//	unpacked bytes
					box += arrTreeToString(charLengths[i]);
				} else {
					//	???
					box += '/*  Unsupported data width  */';
				}
				box += '\n';
			}
			box += '\n';
		} else {	//	blocks
			box += '#define ' + defName + '_DATA_LENGTHS\t';
			if (lengthCharsBpp == 4) {
				//	4-bit packed
				box += arrTreeToString(packNibbles(charLengths));
			} else if (lengthCharsBpp == 8) {
				//	unpacked bytes
				box += arrTreeToString(charLengths);
			} else {
				//	???
				box += '/*  Unsupported data width  */';
			}
			box += '\n\n';
		}

		if (document.getElementsByName('encoderows')[0].checked) {	//	Individual rows
			for (var i = 0; i < encodedChars.length; i++) {
				box += '#define ' + defName + '_FONT_DATA' + i + '\t';
				box += arrTreeToString(encodedChars[i]) + '\n\n';
			}
		} else {	//	blocks
			box += '#define ' + defName + '_FONT_DATA\t';
			box += arrTreeToString(encodedChars) + '\n\n';
		}

		box += '\n\n#endif  //  ' + defName + '_H_INCLUDED\n';
		//	HTML-dodging hack... remember to put these back before saving to file!
		box = box.replace(/\<+/g, '&lt;').replace(/\>+/g, '&gt;');

/*
 *
 * Binary
 *
 */

	} else {	//	if (document.getElementsByName('outputtype')[2].checked)
		f += '.bin';

		var bytes = 0;

		box = 'Binary Size: ' + bytes + '\n';

//		var i = 0;
//		binaryOutput = new Uint8Array(bytes);
//		binaryOutput[i++] = (MAGIC_NUMBER >>> 0) & 0xff;
//		binaryOutput[i++] = (MAGIC_NUMBER >>> 8) & 0xff;

	}
	document.getElementById('filenamebox').value = f;

	document.getElementById('output').innerHTML = box;
	document.getElementById('download').disabled = false;

	document.getElementById('characterbox').max = charWidths.length - 1;
	window.setTimeout(viewChar, 10);
}

function viewChar() {

	if (decodedData) {
		var idx = Number.parseInt(document.getElementById('characterbox').value, 10);
		var zoom = Math.max(Math.min(
				Number.parseInt(document.getElementById('characterzoom').value, 10),
				Number.parseInt(document.getElementById('characterzoom').max, 10) ),
				Number.parseInt(document.getElementById('characterzoom').min, 10) );
		//	Set grid by scale, with some gamma correction
		var gridAlpha = Math.pow(Math.max(Math.min((zoom - 3) / 4, 1), 0), 2);
		idx = Math.max(Math.min(idx, decodedData.widths.length - 1), 0);
		var ctx = document.getElementById('character');
		ctx.width = decodedData.widths[idx] * zoom;
		ctx.height = decodedData.height * zoom;
		ctx = ctx.getContext('2d');
		//	Stretch the character
		var ch = new Uint8ClampedArray(4 * decodedData.widths[idx] * zoom * decodedData.height * zoom);
		var offs = 0;
		for (var i = 0; i < idx; i++) {
			offs += decodedData.widths[i];
		}
		for (var y = 0; y < decodedData.height; y++) {
			for (var x = 0; x < decodedData.widths[idx]; x++) {
				var x1, y1;
				for (var z = 0; z < zoom; z++) {
					for (var w = 0; w < zoom; w++) {
						x1 = x * zoom + w;
						y1 = y * zoom + z;
						ch[4 * (x1 + y1 * decodedData.widths[idx] * zoom) + 0] =
								decodedData.data[4 * (offs + x + y * decodedData.totalWidth) + 0];
						ch[4 * (x1 + y1 * decodedData.widths[idx] * zoom) + 1] =
								decodedData.data[4 * (offs + x + y * decodedData.totalWidth) + 1];
						ch[4 * (x1 + y1 * decodedData.widths[idx] * zoom) + 2] =
								decodedData.data[4 * (offs + x + y * decodedData.totalWidth) + 2];
						ch[4 * (x1 + y1 * decodedData.widths[idx] * zoom) + 3] =
								decodedData.data[4 * (offs + x + y * decodedData.totalWidth) + 3];
					}
				}
			}
		}
		ctx.globalAlpha = 1.0;
		ctx.putImageData(new ImageData(ch, decodedData.widths[idx] * zoom, decodedData.height * zoom), 0, 0);
		if (zoom > 3) {
			//	Draw grid
			ctx.globalAlpha = gridAlpha;
			ctx.strokeStyle = 'rgb(0, 0, 0)';
			for (var y = zoom; y < decodedData.height * zoom; y += zoom) {
				ctx.moveTo(0.5, y + 0.5); ctx.lineTo(decodedData.widths[idx] * zoom - 0.5, y + 0.5);
			}
			for (var x = zoom; x < decodedData.widths[idx] * zoom; x += zoom) {
				ctx.moveTo(x + 0.5, 0.5); ctx.lineTo(x + 0.5, decodedData.height * zoom - 0.5);
			}
			ctx.stroke();
		}
	}

}

function downloadOutput() {
	var f = document.getElementById('filenamebox').value;

	if (document.getElementsByName('outputtype')[2].checked) {	//	Binary
		saveAs(new Blob([binaryOutput], {type: 'application/octet-stream'}), f);
	} else {	//	Text, Header
		var box = document.getElementById('output').innerHTML;
		box.replace(/&gt;/g, '>').replace(/&lt;/g, '<');
		saveAs(new Blob([box], {type: 'text/plain;charset=utf-8'}), f);
	}
}

function clearHTML() {
	document.getElementById('messagebox').innerHTML = '';
	document.getElementById('inputmessage').innerHTML = '';
	document.getElementById('inputwarning').innerHTML = '';
	document.getElementById('outputmessage').innerHTML = '';
	document.getElementById('download').disabled = true;

	var canv = document.getElementById('image');
	canv.width = 100; canv.height = 100;
	canv.getContext('2d').clearRect(0, 0, canv.width, canv.height);
	canv = document.getElementById('decoded');
	canv.width = 100; canv.height = 100;
	canv.getContext('2d').clearRect(0, 0, canv.width, canv.height);
	canv = document.getElementById('character');
	canv.width = 100; canv.height = 100;
	canv.getContext('2d').clearRect(0, 0, canv.width, canv.height);

	imgArray = []; imgWidth = 0; imgHeight = 0;
	binaryOutput = [];
}

/**
 *	Converts a 32-bit integer into a formatted hexadecimal string.
 */
function dwordToHex(b) {
	return '0x' + ('00000000' + (b & 0xffffffff).toString(16)).substr(-8);
}

/**
 *	Converts a 16-bit integer into a formatted hexadecimal string.
 */
function wordToHex(b) {
	return '0x' + ('0000' + (b & 0xffff).toString(16)).substr(-4);
}

/**
 *	Converts an 8-bit integer into a formatted hexadecimal string.
 */
function byteToHex(b) {
	return '0x' + ('00' + (b & 0xff).toString(16)).substr(-2);
}

/**
 *	Recursively counts the number of leaf elements (primitives)
 *	in an array tree.
 */
function arrTreeCount(arr) {
	var n = 0;
	if (Array.isArray(arr)) {
		for (var i of arr) {
			if (Array.isArray(i))
				n += arrTreeCount(i);
			else
				n++;
		}
	}
	return n;
}

/**
 *	Recursively converts leaf elements (primitives) in an
 *	array tree to a nicely formatted comma-separated
 *	hexadecimal string with C-style line wrapping.
 */
function arrTreeToString(arr) {
	var s = '', j = 0, a = arr.flat().flat().flat().flat();
	for (var i of a) {
		if ((j++) % 8 == 0) {
			s += '\t\\\n\t';
		}
		s += byteToHex(i) + ', ';
	}
	s = s.slice(0, s.length - 2);
	return s;
}

/**
 *	Packs the given array into alternate nibbles.
 *	The low 4 bits of arr[i] are used, rest discarded.
 */
function packNibbles(arr) {
	var packed = [];
	for (var i = 0; i < arr.length; i++) {
		if (i % 2 == 1) {
			packed[Math.floor(i / 2)] |= (arr[i] & 0x0f) << 4;
		} else {
			packed.push(arr[i] & 0x0f);
		}
	}
	return packed;
}

/*
 *
 *	Encoder Functions
 *
 */

/**
 *	Codec objects.
 *
 *	Properties:
 *
 *	id
 *		Integer.  Unique identifier or magic number for the codec.
 *
 *	name
 *		String.  Plain text / descriptive name for the codec.
 *
 *	encodeInit(state, symbols)
 *	decodeInit(state, header)
 *		Function.  Initializes state.
 *		state: the state vector.  An empty Object is passed in.
 *		Suggest assigning properties to it.
 *		symbols: an array of {val, freq} objects.
 *			val: palette index / pixel value
 *			freq: the number of times it occurs in the image
 *				Dividing by the total gets PDF, incrementally summing
 *				them gets CDF.  Use to calculate weights, entropy, etc.
 *			Note that these data must be outputted with the encoded data,
 *			for any encoder that uses them.
 *		header: the header from encodeFinal.
 *
 *	encodeStart(state, symbols)
 *	decodeStart(state, header)
 *		Function.  Starts a new data block for encoding.
 *		Typically Init() handles persistent/inter-block state, while
 *		these handle anything that needs to be prepared for a new block.
 *		Codes that don't keep any state between blocks, can also do
 *		initialization here instead.
 *
 *	encodeStep(input, state, output)
 *	decodeStep(input, state)
 *		Function.  Encoder: processes one symbol, or input byte, using
 *		and mutating existing state, optionally outputting byte(s) to
 *		the output array using a output.push() call.
 *		Decoder: input is an iterator, to draw bytes from as needed;
 *		returns one output byte/symbol per call.
 *
 *	encodeEnd(state, output)
 *		Function.  Finishes the current block, flushing any remaining data
 *		to the output.  (decodeEnd is not needed: exactly the dimensions
 *		of the image are Step'd over, leaving no extra data.)
 *
 *	encodeFinal(state)
 *		Function.  Finalizes the encoder state, returning a header (byte
 *		array) containing all information needed to initialize the decoder.
 *		The header must be serialized into a known, consistent, flattened
 *		format, for packing into a binary.
 */

/**	Raw encoder  */
const codecNothing = {
	id: 0x3754,
	name: 'Raw',
	encodeStart: function(state, symbols) {			return;							},
	encodeStep: function(input, state, output) {	output.push(input);				},
	encodeEnd: function(state, output) {			return;							},
	decodeStart: function(state, symbols) {			return;							},
	decodeStep: function(input, state) {			return input.next().value[1];	}
};

/**	Packed nibbles */
const codecNibble = {
	id: 0x3755,
	name: 'Packed Nibbles',
	encodeStart: function(state, symbols) {
		state.nibble = 0; state.byte = 0;
	},
	encodeStep: function(input, state, output) {
		if (state.nibble == 0) {		//	Encode low nibble
			state.byte = input & 0x0f;
			state.nibble = 1;
		} else {					//	Encode high nibble and output
			output.push(state.byte | (input << 4));
			state.nibble = 0;
		}
	},
	encodeEnd: function(state, output) {
		//	Flush extra nibble if present
		if (state.nibble == 1) output.push(state.byte);
	},
	decodeStart: function(state, symbols) {
		state.nibble = 0; state.byte = 0;
	},
	decodeStep: function(input, state) {
		if (state.nibble == 0) {		//	Decode low nibble
			var b = input.next();
			if (b.done) return 0;
			state.byte = b.value[1];
			state.nibble = 1;
			return state.byte & 0x0f;
		} else {					//	Decode high nibble
			state.nibble = 0;
			return (state.byte >>> 4) & 0x0f;
		}
	}
};


/**	Modified Huffman encoding, fixed probability  */
const codecHuffman = {
	id: 0x3756,
	name: '(1, 2, 6) Huffman Code',
	encodeInit: function(state, symbols) {
		state.BUFFERSIZE = 16;
		//	Find two most likely symbols, assign them the lowest-entropy codes
		state.sym1 = 0; state.sym2 = 1;
		state.syms = symbols.length;
		for (var f1 = 0, i = 0; i < symbols.length; i++) {
			if (symbols[i].freq > f1) {
				f1 = symbols[i].freq;
				state.sym1 = i;
			}
		}
		for (var f2 = 0, i = 0; i < symbols.length; i++) {
			if (symbols[i].freq > f2 && symbols[i].freq < f1) {
				f2 = symbols[i].freq;
				state.sym2 = i;
			}
		}
		state.codes = [];
		for (var i = 0; i < symbols.length; i++) {
			state.codes.push( 0x02 | ((i & 0x0f) << 2));
		}
		state.codes[state.sym1] = 0x01;
		state.codes[state.sym2] = 0x00;
		state.bitsPerSymbol = [];
		for (var i = 0; i < symbols.length; i++) {
			state.bitsPerSymbol.push(6);
		}
		state.bitsPerSymbol[state.sym1] = 1;
		state.bitsPerSymbol[state.sym2] = 2;
	},
	encodeStart: function(state, symbols) { 
		state.shifts = 0;
		state.bits = 0;
		state.buffer = [];
	},
	encodeStep: function(input, state, output) {
		//	Buffer input so we can early-out at the end
		state.buffer.push(input);
		if (state.buffer.length >= state.BUFFERSIZE) {
			input = state.buffer.shift();
			state.bits |= state.codes[input] << state.shifts;
			state.shifts += state.bitsPerSymbol[input];
			if (state.shifts >= 8) {
				output.push(state.bits & 0xff);
				state.shifts -= 8;
				state.bits >>>= 8;
			}
		}
	},
	encodeEnd: function(state, output) {
		while (state.buffer.length > 0) {
			//	Check if buffer is all sym1's -- we can leave early
			if (checkArrayAllValue(state.buffer, state.sym1)) {
				//	But first, make sure the current byte is full
				if (state.shifts == 0) break;
				while (state.shifts < 8) {
					state.bits |= state.codes[state.sym1] << state.shifts;
					state.shifts += state.bitsPerSymbol[state.sym1];
				}
				break;
			}
			var input = state.buffer.shift();
			state.bits |= state.codes[input] << state.shifts;
			state.shifts += state.bitsPerSymbol[input];
			if (state.shifts >= 8) {
				output.push(state.bits & 0xff);
				state.shifts -= 8;
				state.bits >>>= 8;
			}
		}
		while (state.shifts > 0) {
			output.push(state.bits & 0xff);
			state.shifts -= 8;
			state.bits >>>= 8;
		}

		function checkArrayAllValue(a, v) {
			for (var i = 0; i < a.length; i++) {
				if (a[i] != v) return false;
			}
			return true;
		}
	},
	encodeFinal: function(state) {
		//	Store the important values: number of symbols,
		//	and the two most common symbols sym1 and sym2
		return [state.syms, state.sym1, state.sym2];
	},
	decodeInit: function(state, header) {
		state.BUFFERSIZE = 16;
		//	Get the two most likely symbols
		state.syms = header[0];
		state.sym1 = header[1];
		state.sym2 = header[2];
		state.codes = [];
		for (var i = 0; i < state.syms; i++) {
			state.codes.push( 0x02 | ((i & 0x0f) << 2));
		}
		state.codes[state.sym1] = 0x01;
		state.codes[state.sym2] = 0x00;
		state.bitsPerSymbol = [];
		for (var i = 0; i < state.syms; i++) {
			state.bitsPerSymbol.push(6);
		}
		state.bitsPerSymbol[state.sym1] = 1;
		state.bitsPerSymbol[state.sym2] = 2;
	},
	decodeStart: function(state, header) {
		state.shifts = 0;
		state.bits = 0;
		state.buffer = [];
	},
	decodeStep: function(input, state) {
		var sym;
		if (state.shifts < 8) {
			var b = input.next();
			if (b.done) b.value = [0, 0xff];
			state.bits |= b.value[1] << state.shifts;
			state.shifts += 8;
		}
		if ((state.bits & ((1 << state.bitsPerSymbol[state.sym1]) - 1)) == state.codes[state.sym1]) {
			//	Shortest code
			sym = state.sym1;
		} else if ((state.bits & ((1 << state.bitsPerSymbol[state.sym2]) - 1)) == state.codes[state.sym2]) {
			//	Second shortest code
			sym = state.sym2;
		} else {	//	Other
			sym = (state.bits >>> 2) & 0x0f;
		}
		state.shifts -= state.bitsPerSymbol[sym]; state.bits >>>= state.bitsPerSymbol[sym];
		return Math.min(sym, state.syms);
	}
};


/**	Arithmetic encoder, DWORDs  */
const codecArithD = {
	id: 0x3757,
	name: 'Arithmetic Code, DWORDs',
	encodeInit: function(state, symbols) {
		state.MAXVAL = 256;
		state.accum = 0;
		state.LOGDEF = state.MAXVAL / 8;	//	Adjusts quality (error at end of DWORD)
		state.pdf = [];
		state.cdf = [0];
		state.muls = [];
		state.logs = [];
		var syms;
		
		//	Partition the symbols over range 0...MAXVAL using the Huntington-Hill method
		syms = Math.min(symbols.length, state.MAXVAL - 1);
		var total = 0;
		for (var i = 0; i < syms; i++) {
			state.pdf.push(1);
			total++;
		}
		//	cache the weighing function to save a little time
		var weight = [state.MAXVAL - 1];
		for (var i = 1; i < state.MAXVAL; i++) {
			weight.push(1 / Math.sqrt(i * (i + 1)));
		}
		while (total < state.MAXVAL) {
			//	Find the symbol with the highest quotient and increment it
			var q = 0, j = 0, thisq;
			for (var i = 0; i < syms; i++) {
				thisq = symbols[i].freq * weight[state.pdf[i]];
				if (thisq > q) {
					q = thisq; j = i;
				}
			}
			state.pdf[j]++; total++;
		}
		for (var i = 0; i < syms; i++) {
			state.logs.push(Math.ceil(state.MAXVAL * (8 - Math.log(state.pdf[i]) / Math.log(2)) / 32));
			if (state.logs[i] < 1) state.logs[i] = 1;
			if (state.logs[i] > state.MAXVAL - 1) state.logs[i] = state.MAXVAL - 1;
			state.muls.push(Math.ceil(65536 / state.pdf[i]) / 256);
			if (state.muls[i] >= 256) state.muls[i] = 255 + 255 / 256;
			state.cdf.push(state.pdf[i] + state.cdf[i]);
		}
	},
	encodeStart: function(state, symbols) { 
		state.divisor = 1;
		state.logacc = state.LOGDEF;
	},
	encodeStep: function(input, state, output) {
		if (state.logacc >= state.MAXVAL) {
			//	0.32 fixed point format
			state.accum = Math.ceil(state.accum * 0x1000000);
			output.push(state.accum & 0xff); state.accum >>>= 8;
			output.push(state.accum & 0xff); state.accum >>>= 8;
			output.push(state.accum & 0xff); state.accum >>>= 8;
			output.push(state.accum & 0xff); state.accum = 0;
			state.divisor = 1;
			state.logacc = state.LOGDEF;
		}
		state.accum += state.cdf[input] * state.divisor;
		state.logacc += state.logs[input];
		state.divisor /= state.muls[input];
	},
	encodeEnd: function(state, output) {
		state.accum = Math.ceil(state.accum * 0x1000000);
		output.push(state.accum & 0xff); state.accum >>>= 8;
		output.push(state.accum & 0xff); state.accum >>>= 8;
		output.push(state.accum & 0xff); state.accum >>>= 8;
		output.push(state.accum & 0xff); state.accum = 0;
	},
	encodeFinal: function(state) {
		/*
		 *	header[0] = number of symbols (syms)
		 *	header[1...syms] = pdf
		 *	header[syms+1...2*syms+1] = logs
		 *	header[2*syms+2...4*syms+2] = muls (byte-packed words)
		 *
		 *	Note: logs and muls can be strictly omitted, but they're kind of annoying
		 *	to calculate, so it may be desirable to include them for an embedded target.
		 */
		var h = [];
		h.push(state.pdf.length);
		for (var i = 0; i < state.pdf.length; i++) {
			h.push(state.pdf[i]);
		}
		for (var i = 0; i < state.pdf.length; i++) {
			h.push(state.logs[i]);
		}
		for (var i = 0; i < state.pdf.length; i++) {
			h.push((state.muls[i] * 256) & 0xff);
			h.push(state.muls[i] & 0xff);
		}
		return h;
	},
	decodeInit: function codecArithDInit(state, header) {
		state.MAXVAL = 256;
		state.accum = 0;
		state.LOGDEF = state.MAXVAL / 8;	//	Adjusts quality (error at end of DWORD)
		state.pdf = [];
		state.cdf = [0];
		state.muls = [];
		state.logs = [];
		//	Convert header into symbol-derived data
		var syms = header[0];
		for (var i = 0; i < syms; i++) {
			state.pdf.push(header[i + 1]);
			state.logs.push(header[syms + i + 1]);
			if (state.logs[i] == 0) state.logs = state.MAXVAL - 1;
			state.muls.push(header[2 * (syms + i) + 1] / 256 + header[2 * (syms + i) + 2]);
			state.cdf.push(state.pdf[i] + state.cdf[i]);
		}
	},
	decodeStart: function(state, header) {
		state.accum = 0;
		state.logacc = state.MAXVAL;
	},
	decodeStep: function(input, state) {
		if (state.logacc >= state.MAXVAL) {
			//	Get new DWORD to decode
			state.accum = 0;
			state.logacc = state.LOGDEF;
			for (var i = 0; i < 4; i++) {
				var b = input.next();
				if (b.done) break;
				state.accum = (state.accum / 256) + (b.value[1] & 0xff);
			}
		}
		var output = -1;
		for (var i = state.cdf.length - 2; i >= 0; i--) {
			if (state.accum >= state.cdf[i]) {
				output = i;
				break;
			}
		}
		state.accum -= state.cdf[output];
		state.accum *= state.muls[output];
		state.logacc += state.logs[output];
		return output;
	}
};


/**	Arithmetic encoder, fixed probability  */
const codecArithFixed = {
	id: 0x3758,
	name: 'Arithmetic Code, Stream, Fixed Model',
	encodeInit: function(state, symbols) {
		state.TOP_VALUE	= 0xffff;
		state.MAX_SCALE	= 0x3fff;
		state.FIRST_QTR	= (Math.floor(state.TOP_VALUE / 4) + 1);
		state.HALF		= (2 * state.FIRST_QTR);
		state.THIRD_QTR	= (3 * state.FIRST_QTR);
		state.ACODER_N	= symbols.length;
		state.low		= 0;
		state.high		= state.TOP_VALUE;
		state.pending	= 0;
		state.byte		= 0;
		state.bit		= 0;
		state.cdf = [0];
		for (var i = 0; i < state.ACODER_N; i++) {
			state.cdf.push(symbols[i].freq + state.cdf[i]);
		}
		while (state.cdf[state.cdf.length - 1] >= state.MAX_SCALE) {
			//	Clamp everything to reasonable values
			var reduction = (state.MAX_SCALE + 1) / state.cdf[state.cdf.length - 1];
			for (var i = 0; i < state.ACODER_N; i++) {
				state.cdf[i] = Math.ceil(state.cdf[i] * reduction);
			}
			//	Do an awkward scan just to make sure nothing has disappeared
			for (var i = 1; i < state.ACODER_N; i++) {
				if (state.cdf[i] - state.cdf[i - 1] < 1) {
					for (var j = i; j < state.ACODER_N; j++) {
						state.cdf[j]++;
					}
				}
			}
		}
	},
	encodeStart: function(state, symbols) {
		state.low		= 0;
		state.high		= state.TOP_VALUE;
		state.pending	= 0;
		state.byte		= 0;
		state.bit		= 0;
	},
	encodeStep: function(input, state, output) {
		var range = state.high - state.low + 1;
		state.high = Math.floor(state.low + (range * state.cdf[input + 1]) / state.cdf[state.ACODER_N] - 1);
		state.low  = Math.floor(state.low + (range * state.cdf[input])	 / state.cdf[state.ACODER_N]);
		while (1) {
			if (state.high < state.HALF) {
				codecArithAdapt_output_bit_and_pending(state, output, 0);
			} else if (state.low >= state.HALF) {
				codecArithAdapt_output_bit_and_pending(state, output, 1);
				state.low  -= state.HALF;
				state.high -= state.HALF;
			} else if (state.low >= state.FIRST_QTR && state.high < state.THIRD_QTR) {
				state.pending++;
				state.low  -= state.FIRST_QTR;
				state.high -= state.FIRST_QTR;
			} else
				break;
			state.low  = state.low * 2;
			state.high = state.high * 2 + 1;
		}
	},
	encodeEnd: function(state, output) {
		state.pending++;
		if (state.low < state.FIRST_QTR)
			codecArithAdapt_output_bit_and_pending(state, output, 0);
		else
			codecArithAdapt_output_bit_and_pending(state, output, 1);
		output.push(state.byte);
	},
	encodeFinal: function(state) {
		var h = [];
		//	header[0..1] = number of symbols
		//	header[2..3] = cdf[1] (cdf[0] is trivial 0)
		//	. . .
		//	header[syms..syms+1] = cdf[syms+1]
		h.push(state.ACODER_N & 0xff);
		h.push((state.ACODER_N >>> 8) & 0xff);
		for (var i = 1; i < state.cdf.length; i++) {
			h.push(state.cdf[i] & 0xff);
			h.push((state.cdf[i] >>> 8) & 0xff);
		}
		return h;
	},
	decodeInit: function(state, header) {
		state.TOP_VALUE	= 0xffff;
		state.MAX_SCALE	= 0x3fff;
		state.FIRST_QTR	= (Math.floor(state.TOP_VALUE / 4) + 1);
		state.HALF		= (2 * state.FIRST_QTR);
		state.THIRD_QTR	= (3 * state.FIRST_QTR);
		state.ACODER_N	= header[0] + (header[1] << 8);
		state.cdf = [0];
		for (var i = 0; i < state.ACODER_N; i++) {
			state.cdf.push(header[2 * i + 2] + header[2 * i + 3] * 256);
		}
	},
	decodeStart: function(state, header) {
		state.low		= 0;
		state.high		= state.TOP_VALUE;
		state.value		= 0;
		state.bit		= 7;
		state.firstRun = true;
	},
	decodeStep: function(input, state) {
		//	Moved from decodeStart because it's not passed any input
		if (state.firstRun) {
			for (var i = 0; i < 16; i++)
				state.value = (state.value << 1) | codecArithAdapt_input_bit(state, input);
			state.firstRun = false;
		}
		var range = state.high - state.low + 1;
		var val = Math.floor(((state.value - state.low + 1) * state.cdf[state.ACODER_N] - 1) / range);
		var b;
		for (b = state.ACODER_N; val < state.cdf[b]; b--);
		state.high = Math.floor(state.low + (range * state.cdf[b + 1]) / state.cdf[state.ACODER_N] - 1);
		state.low  = Math.floor(state.low + (range * state.cdf[b])	 / state.cdf[state.ACODER_N]);
		while (1) {
			if (state.high < state.HALF) {
				// Do nothing
			} else if (state.low >= state.HALF) {
				state.value -= state.HALF;
				state.low   -= state.HALF;
				state.high  -= state.HALF;
			} else if (state.low >= state.FIRST_QTR && state.high < state.THIRD_QTR) {
				state.value -= state.FIRST_QTR;
				state.low   -= state.FIRST_QTR;
				state.high  -= state.FIRST_QTR;
			} else {
				break;
			}
			state.low   = state.low * 2;
			state.high  = state.high * 2 + 1;
			state.value = (state.value << 1) | codecArithAdapt_input_bit(state, input);
		}
		return b;
	}
};


/**	Arithmetic encoder, adaptive  */
/*	See: https://github.com/ataradov/random  */
const codecArithAdapt = {
	id: 0x3759,
	name: 'Arithmetic Code, Stream, Adaptive Model',
	encodeStart: function(state, symbols) {
		state.TOP_VALUE	= 0xffff;
		state.MAX_SCALE	= 0x3fff;
		state.FIRST_QTR	= (Math.floor(state.TOP_VALUE / 4) + 1);
		state.HALF		= (2 * state.FIRST_QTR);
		state.THIRD_QTR	= (3 * state.FIRST_QTR);
		state.ACODER_N	= symbols.length;
		state.low		= 0;
		state.high		= state.TOP_VALUE;
		state.pending	= 0;
		state.byte		= 0;
		state.bit		= 0;
		state.cdf = [];
		for (var i = 0; i < state.ACODER_N + 1; i++) {
			state.cdf.push(i);
		}
	},
	encodeStep: function(input, state, output) {
		var range = state.high - state.low + 1;
		state.high = Math.floor(state.low + (range * state.cdf[input + 1]) / state.cdf[state.ACODER_N] - 1);
		state.low  = Math.floor(state.low + (range * state.cdf[input])	 / state.cdf[state.ACODER_N]);
		while (1) {
			if (state.high < state.HALF) {
				codecArithAdapt_output_bit_and_pending(state, output, 0);
			} else if (state.low >= state.HALF) {
				codecArithAdapt_output_bit_and_pending(state, output, 1);
				state.low  -= state.HALF;
				state.high -= state.HALF;
			} else if (state.low >= state.FIRST_QTR && state.high < state.THIRD_QTR) {
				state.pending++;
				state.low  -= state.FIRST_QTR;
				state.high -= state.FIRST_QTR;
			} else
				break;
			state.low  = state.low * 2;
			state.high = state.high * 2 + 1;
		}
		codecArithAdapt_model_update(state, input);
	},
	encodeEnd: function(state, output) {
		state.pending++;
		if (state.low < state.FIRST_QTR)
			codecArithAdapt_output_bit_and_pending(state, output, 0);
		else
			codecArithAdapt_output_bit_and_pending(state, output, 1);
		output.push(state.byte);
	},
	encodeFinal: function(state) {
		return [state.ACODER_N];
	},
	decodeStart: function(state, header) {
		state.TOP_VALUE	= 0xffff;
		state.MAX_SCALE	= 0x3fff;
		state.FIRST_QTR	= (Math.floor(state.TOP_VALUE / 4) + 1);
		state.HALF		= (2 * state.FIRST_QTR);
		state.THIRD_QTR	= (3 * state.FIRST_QTR);
		state.ACODER_N	= header[0];
		state.low		= 0;
		state.high		= state.TOP_VALUE;
		state.value		= 0;
		state.bit		= 7;
		state.firstRun = true;
		state.cdf = [];
		for (var i = 0; i < state.ACODER_N + 1; i++) {
			state.cdf.push(i);
		}
	},
	decodeStep: function(input, state) {
		//	Moved from decodeStart because it's not passed any input
		if (state.firstRun) {
			for (var i = 0; i < 16; i++)
				state.value = (state.value << 1) | codecArithAdapt_input_bit(state, input);
			state.firstRun = false;
		}
		var range = state.high - state.low + 1;
		var val = Math.floor(((state.value - state.low + 1) * state.cdf[state.ACODER_N] - 1) / range);
		var b;
		for (b = state.ACODER_N; val < state.cdf[b]; b--);
		state.high = Math.floor(state.low + (range * state.cdf[b + 1]) / state.cdf[state.ACODER_N] - 1);
		state.low  = Math.floor(state.low + (range * state.cdf[b])	 / state.cdf[state.ACODER_N]);
		while (1) {
			if (state.high < state.HALF) {
				// Do nothing
			} else if (state.low >= state.HALF) {
				state.value -= state.HALF;
				state.low   -= state.HALF;
				state.high  -= state.HALF;
			} else if (state.low >= state.FIRST_QTR && state.high < state.THIRD_QTR) {
				state.value -= state.FIRST_QTR;
				state.low   -= state.FIRST_QTR;
				state.high  -= state.FIRST_QTR;
			} else {
				break;
			}
			state.low   = state.low * 2;
			state.high  = state.high * 2 + 1;
			state.value = (state.value << 1) | codecArithAdapt_input_bit(state, input);
		}
		codecArithAdapt_model_update(state, b);
		return b;
	}
};
//	Helper functions
function codecArithAdapt_output_bit_and_pending(state, output, bit) {
	codecArithAdapt_output_bit(state, output, bit);
	for (; state.pending; state.pending--) {
		codecArithAdapt_output_bit(state, output, !bit);
	}
}
function codecArithAdapt_output_bit(state, output, value) {
	state.byte |= (value << state.bit);
	if (8 == ++state.bit) {
		output.push(state.byte);
		state.byte = 0;
		state.bit = 0;
	}
}
function codecArithAdapt_input_bit(state, input) {
	var res;
	state.bit++;
	if (8 == state.bit) {
		var b = input.next();
		if (b.done)
			state.byte = 0;
		else
			state.byte = b.value[1];
		state.bit = 0;
	}
	res = state.byte & 1;
	state.byte >>>= 1;
	return res;
}
function codecArithAdapt_model_update(state, input) {
	var last = 0;
	var value = 0;
	if (state.cdf[state.ACODER_N] == state.MAX_SCALE) {
		for (var i = 0; i < state.ACODER_N; i++) {
			value = state.cdf[i + 1] - last;
			last = state.cdf[i + 1];
			state.cdf[i + 1] = state.cdf[i] + Math.floor((value + 1) / 2);
		}
	}
	for (var i = input; i < state.ACODER_N; i++) {
		state.cdf[i + 1]++;
	}
}


/**	Run Length Encoder, Nibble Commands  */
/*
 *	Command format:
 *	0bZYXX
 *	Z = 0: most common symbol (color 15?), run of YXX + 1 = 1..8
 *	Z = 1:
 *		Y = 0: second most common symbol (color 0?), run of XX + 1 = 1..4
 *		Y = 1: least common symbols, run of XX + 1 = 1..4 (values follow
 *			   in subsequent nibbles)
 */
function codecRLEEncodeBuffer(state, output) {
	var cmd, i;
	for (i = 0; i < Math.min(7, state.buffer.length - 1); i++) {
		if (state.buffer[i + 1] != state.buffer[i])
			break;
	}
	//	Found a run, encode it
	if (state.buffer[0] == state.sym1) {
		cmd = [i & 0x07];
		state.buffer = state.buffer.slice(i + 1);
	} else if (state.buffer[0] == state.sym2) {
		if (i > 3) i = 3;
		cmd = [(i & 0x03) | 0x08];
		state.buffer = state.buffer.slice(i + 1);
	} else {
		//	Run of other symbols, see how many in a row
		for (i = 1; i < 4; i++) {
			//	Found a common symbol. But is it repeated? If not, we can inline
			//	it here without much overhead
			if (((state.buffer[i] == state.sym1) || (state.buffer[i] == state.sym2))
					&& state.buffer[i + 1] == state.buffer[i])
				break;
		}
		i--;
		cmd = [(i & 0x03) | 0x0c];
		for (; i >= 0; i--)
			cmd.push(state.buffer.shift());
	}
	for (i = 0; i < cmd.length; i++) {
		if (state.nibble == 0) {		//	Encode low nibble
			state.byte = cmd[i] & 0x0f;
			state.nibble = 1;
		} else {					//	Encode high nibble and output
			output.push(state.byte | (cmd[i] << 4));
			state.nibble = 0;
		}
	}
}
const codecRLE = {
	id: 0x375a,
	name: 'Run Length Encoder',
	encodeStart: function(state, symbols) {
		state.BUFFERSIZE = 16;
		state.buffer = [];
		state.nibble = 0;
		state.byte = 0;
		//	Find two most likely symbols, assign them the lowest-entropy codes
		state.sym1 = 0; state.sym2 = 1;
		for (var f1 = 0, i = 0; i < symbols.length; i++) {
			if (symbols[i].freq > f1) {
				f1 = symbols[i].freq;
				state.sym1 = i;
			}
		}
		for (var f2 = 0, i = 0; i < symbols.length; i++) {
			if (symbols[i].freq > f2 && symbols[i].freq < f1) {
				f2 = symbols[i].freq;
				state.sym2 = i;
			}
		}
	},
	encodeStep: function(input, state, output) {
		//	For simplicity, just buffer the whole block
		state.buffer.push(input);
	},
	encodeEnd: function(state, output) {
		while (state.buffer.length > 0) {
			//	Try early out: decoder will read sym1's past EOF
			if (state.buffer.every(x => x == state.sym1)) break;
			//	Oh well, keep cranking
			codecRLEEncodeBuffer(state, output);
		}
		//	Flush extra nibble if present
		if (state.nibble == 1) output.push(state.byte);
	},
	encodeFinal: function(state) {
		return [state.sym1, state.sym2];
	},
	decodeStart: function (state, header) {
		state.BUFFERSIZE = 16;
		state.buffer = [];
		state.nibble = 0;
		state.byte = 0;
		state.sym1 = header[0];
		state.sym2 = header[1];
	},
	decodeStep: function(input, state) {
		if (state.buffer.length == 0) {	//	Empty buffer, fetch and process command
			var cmd = getNibble();
			if ((cmd & 0x08) == 0) {			//	Run of sym1's
				for (var i = 0; i <= (cmd & 0x07); i++) {
					state.buffer.push(state.sym1);
				}
			} else if ((cmd & 0x0c) == 0x08) {	//	Run of sym2's
				for (var i = 0; i <= (cmd & 0x03); i++) {
					state.buffer.push(state.sym2);
				}
			} else {							//	Run of nibbles
				for (var i = 0; i <= (cmd & 0x03); i++) {
					state.buffer.push(getNibble());
				}
			}
		}
		return state.buffer.shift();

		function getNibble() {
			if (state.nibble == 0) {	//	Get low nibble
				var b = input.next();
				if (b.done) return 0;
				state.byte = b.value[1];
				state.nibble = 1;
				return state.byte & 0x0f;
			} else {					//	Get high nibble
				state.nibble = 0;
				return (state.byte >>> 4) & 0x0f;
			}
		}
	}
};


/**	Dictionary Coding  */
const codecDict = {
	id: 0x375b,
	name: 'Dictionary Coding',
	encodeInit: function(state, symbols) {
		state.DICTMAX = 256;
		state.syms = symbols.length;
		state.blocks = [];
		//	Find the most common symbol, optimize around that where possible
		state.sym1 = 0;
		var totalsyms = 0;
		for (var f1 = 0, i = 0; i < symbols.length; i++) {
			totalsyms += symbols[i].freq;
			if (symbols[i].freq > f1) {
				f1 = symbols[i].freq;
				state.sym1 = i;
			}
		}
		//	Measure entropy and assert a corresponding maximum word length
		var e = 0;
		for (var i of symbols) {
			e -= (i.freq / totalsyms) * Math.log(i.freq / totalsyms) / Math.LN2;
		}
		state.maxWordLength = Math.ceil(12 / e);
	},
	encodeStart: function(state, symbols) {
		//	Start new block
		state.blocks.push([]);
	},
	encodeStep: function(input, state, output) {
		//	Buffer the current block
		state.blocks[state.blocks.length - 1].push(input);
	},
	encodeEnd: function(state, output) {
		//	Cheat by hanging onto the output reference for outputting everything in Final...
		state.blocks[state.blocks.length - 1].outref = output;
		//	We'll be sorting this array repeatedly; hold onto the original
		//	index so we can put it back into its original block order
		state.blocks[state.blocks.length - 1].index = state.blocks.length - 1;
		return;
	},
	encodeFinal: function(state) {
		var outbuf = [];
		state.dict = [];
		//	Load dictionary with trivial words (single symbols)
		for (var i = 0; i < state.syms; i++) {
			state.dict.push([i]);
			state.dict[i].use = 0;
		}
		for (var i = 0; i < state.blocks.length; i++) {
			outbuf.push([]);
			outbuf[i].outref = state.blocks[i].outref;
		}

/*
//	Testing Lucidia_16px, rows
//	with pre-check: 3168
//	without: 4355
		//	Pre-check for trivial strings or suffixes (ending in sym1's)
		for (var i = 0; i < state.blocks.length; i++)
			if (state.blocks[i].every(x => x == state.sym1))
				state.blocks[i].length = 0;
		for (var i = 0; i < state.blocks.length; i++)
			while (state.blocks[i][state.blocks[i].length - 1] == state.sym1)
				state.blocks[i].pop();

		//	Sort the blocks lexicographically, and find runs of common prefixes.
		//	Add those prefixes to the dictionary, remove them from the blocks
		//	and commit those words to the output buffer.
		//	TODO: only works because there are many blocks in a font.  Chop up oversized
		//	blocks (>64 length?) into sub-blocks and process in this manner, then stitch
		//	together their outputs somehow.
		var runs = [0]; runs.length = state.blocks.length;
		while (true) {
			state.blocks.sort((a, b) => (codecDictArrayCompare(a, b)));

			//	Remove empty blocks, terminate when none are left
			while (state.blocks.length && state.blocks[0].length == 0) {
				state.blocks.shift();
				runs.shift();
				runs[0] = 0;
			}
			if (state.blocks.length == 0) break;

			for (var i = 1; i < state.blocks.length; i++) {
				//	Compare this row to previous, symbol by symbol
				for (var j = 0;
						j < state.blocks[i].length &&
						j < state.blocks[i - 1].length &&
						state.blocks[i][j] == state.blocks[i - 1][j];
						j++);
				runs[i] = j;
			}

			var bestRun = codecDictMaxHistogram(runs);	//	{row:, height:, width:, cnt:}
			if (bestRun.width < state.MINWORD) {
				//	No useful runs, all blocks start with high-entropy symbols, remove one pass and check again
				for (var i = 0; i < state.blocks.length; i++) {
					d = state.blocks[i][0];
					state.dict[d].use++;
					state.blocks[i].splice(0, 1);
					outbuf[state.blocks[i].index].push(d);
				}
			} else {
				//	Useful run, see if we have it already, if not add it to the dictionary
				var d = 0, w = 0;
				var prefix = state.blocks[bestRun.row - 1].slice(0, bestRun.width);
				for (; d < state.dict.length; d++) {
					w = codecDictArrayMatch(prefix, state.dict[d]);
					if (w == bestRun.width) break;	//	Found it
				}
				if (d >= state.dict.length) {
					//	It's new, add to dictionary
					state.dict.push(prefix);
					d = state.dict.length - 1;
					state.dict[d].use = 0;
				}
			}

			//	Scan for nontrivial words already in the dictionary
			for (var i = 0; i < state.blocks.length; i++) {
				if (state.blocks[i].length) {
					//	TODO: replace with sorted dictionary and binary search
					var width = 0, word = 0;
					for (var d = state.syms; d < state.dict.length; d++) {
						var w = codecDictArrayMatch(state.blocks[i], state.dict[d]);
						if (w > width) {
							width = w; word = d;
						}
					}
					if (word) {
						state.blocks[i].splice(0, width);
						outbuf[state.blocks[i].index].push(word); state.dict[word].use++;
						i--;
					}
				}
			}
		}
*/

/*
		//	Create a suffix array across all blocks

		//	First join all blocks with an EOL marker...
		//	Also shift everything up by one, to reserve value 0 as EOL
		//	(the suffix array algorithm doesn't work for non-unsigned-
		//	byte values, so this limits the symbol space slightly)
		var concat = [];
		for (var i = 0; i < state.blocks.length; i++) {
			for (var j = 0; j < state.blocks[i].length; j++) {
				concat.push(Math.min(state.blocks[i][j] + 1, 255));
			}
			concat.push(0);
		}
		state.dict = [];
		var sa = codecDictSuffixArray(concat, concat.length);
		//	Ignore the first run of lines that start with EOLs
		sa.splice(0, sa.findIndex(e => concat[e] > 0));
		var runs = [0];
		for (var i = 1; i < sa.length; i++) {
			//	Compare this row to previous, symbol by symbol
			for (var j = 0; ; j++)
				if ((concat[sa[i] + j] != concat[sa[i - 1] + j]) ||
						concat[sa[i] + j] == 0)
					break;
			runs.push(j);
		}
		while (true) {
			var bestRun = codecDictMaxHistogram(runs);
			//	Done when no more blocks of useful height or width, or dictionary too oversized
			if (sa.length == 0 || bestRun.height == 0 || state.dict.length >= state.DICTMAX * 4) {
				break;
			}
			if (bestRun.height >= 1 && bestRun.width >= 2) {
				//	Found a good size prefix, save it to dictionary
				state.dict.push(concat.slice(sa[bestRun.row], sa[bestRun.row] + bestRun.width));
				//	Building dictionary from the one-offset concatenated array; correct this
				for (var i = 0; i < state.dict[state.dict.length - 1].length; i++) {
					state.dict[state.dict.length - 1][i]--;
				}
			}
			//	Cut out matching runs
			for (var i = 0, j = bestRun.row; i < bestRun.height; i++) {
				if (runs[j] == bestRun.width) {
					sa.splice(bestRun.row, 1);
					runs.splice(bestRun.row, 1);
				} else
					j++;
			}
		}
		//	Also load dictionary with trivial words (single symbols)
		for (var i = state.syms - 1; i >= 0; i--) {
			state.dict.unshift([i]);
		}
		//	Finally, translate blocks to words
		var pass = codecDictTranslateWordsGreedy(state.dict, state.blocks);
		//	Sort by usage...
		for (var i = 0; i < state.dict.length; i++)
			state.dict[i].use = pass.use[i];
		var triv = state.dict.splice(0, state.syms);
		state.dict.sort((a, b) => (b.use - a.use));
		state.dict = triv.concat(state.dict);
		//	Crop down to DICTMAX, and/or remove least used elements
		state.dict.length = Math.min(state.dict.findIndex((a, i) => a.use <= 2 && i > state.syms), state.DICTMAX);
		outbuf = codecDictTranslateWordsGreedy(state.dict, state.blocks);
		for (var i = state.syms; i < state.dict.length; i++) {
			state.dict[i].use = outbuf.use[i];
			if (outbuf.use[i] == 0) {
				state.dict.splice(i, 1);
				outbuf.use.splice(i, 1);
				for (var j = 0; j < outbuf.length; j++)
					for (var k = 0; k < outbuf[j].length; k++)
						outbuf[j][k] = outbuf[j][k] - (outbuf[j][k] > i);
				i--;
			}
		}
*/


		//	Create a suffix array across all blocks
		var concat = [];
		for (var i = 0; i < state.blocks.length; i++) {
			for (var j = 0; j < state.blocks[i].length; j++) {
				concat.push(Math.min(state.blocks[i][j] + 1, 255));	//	off-by-one hack for bsort
			}
			concat.push(0);
		}
		var sa = codecDictSuffixArray(concat, concat.length);
		for (var i = 0; i < concat.length; i++) concat[i]--;		//	dehack (note: EOL == -1)
		//	Cut the run of EOLs at the start
		sa.splice(0, sa.findIndex(e => concat[e] >= 0));
		var runs = [0];
		for (var i = 1; i < sa.length; i++) {
			//	Compare this row to previous, symbol by symbol
			for (var j = 0; ; j++)
				if ((concat[sa[i] + j] != concat[sa[i - 1] + j]) ||
						concat[sa[i] + j] < 0)
					break;
			runs.push(j);
		}
		//	Fill dictionary with every possibly useful word, sorted by length
		var longestWord = 0;
		for (var i = 1; i < runs.length; i++) {
			if (runs[i] != runs[i - 1] && runs[i] > 1) {
				//	New one, add to dictionary
				var w = concat.slice(sa[i], sa[i] + runs[i]);
				if ((() => {	//	Check if not in dictionary
					for (var j = 0; j < state.dict.length; j++)
						if (codecDictArrayCompare(state.dict[j], w) == 0)
							return false;
					return true;
				})() &&	w.length < state.maxWordLength) {	//	Also check if within desired length range
					state.dict.push(w);
					if (state.dict[state.dict.length - 1].length > longestWord)
						longestWord = state.dict[state.dict.length - 1].length;
				}
			}
		}
		state.dict.sort((a, b) => (b.length == 1 || (b.length - a.length)));
		state.dict.syms = state.syms;

		var progress;
		do {
			progress = false;

			//	Dictionary-ify it
			//outbuf = codecDictTranslateWordsGreedy(state.dict, state.blocks);
			outbuf = codecDictTranslateWordsDynprog(state.dict, state.blocks);
			//	Prune poorly used words
			for (var i = state.syms; i < state.dict.length; i++) {
				if ((outbuf.use[i] == 1) ||
						(state.dict[i].length == 2 && outbuf.use[i] <= 3) ||
						(state.dict[i].length == 3 && outbuf.use[i] <= 2)) {
					progress = true;
					state.dict.splice(i, 1);
					outbuf.use.splice(i, 1);
					i--;
				}
			}
			//	Prune words that are too similar
		} while (progress);

		//	Finally, prune unused words
		for (var i = state.syms; i < state.dict.length; i++) {
			if (outbuf.use[i] == 0) {
				state.dict.splice(i, 1);
				outbuf.use.splice(i, 1);
				i--;
				for (var j = 0; j < outbuf.length; j++) {
					for (var k = 0; k < outbuf[j].length; k++) {
						if (outbuf[j][k] > i)
							outbuf[j][k]--;
					}
				}
			}
		}

		//	copy usage over from outbuf
		for (var i = 0; i < state.dict.length; i++) {
			state.dict[i].use = outbuf.use[i];
		}
		for (var i = 0; i < state.blocks.length; i++) {
			outbuf[i].outref = state.blocks[i].outref;
		}

		//	Output to those refs we sneakily stole earlier...
		for (var i = 0; i < outbuf.length; i++)
			outbuf[i].forEach(x => outbuf[i].outref.push(x));

		/*
		 *	Create a header of the dictionary and metadata
		 *	header[0] = number of symbols (syms)
		 *	header[1] = most common symbol
		 *	header[2] = number of words in dictionary, not counting trivial words (dictsize)
		 *	header[3...dictsize+2] = lengths of dictionary words
		 *	header[dictsize+3...] = dictionary words (unpacked bytes)
		 */
		var header = [state.syms, state.sym1, state.dict.length - state.syms];
		//	Don't store the first syms words (trivial)
		for (var i = state.syms; i < state.dict.length; i++) {
			header.push(state.dict[i].length);
		}
		for (var i = state.syms; i < state.dict.length; i++) {
			state.dict[i].forEach(x => header.push(x));
		}
		return header;
	},
	decodeInit: function(state, header) {
		state.dict = [];
		state.syms = header[0];
		state.sym1 = header[1];
		for (var i = 0; i < state.syms; i++) {
			state.dict.push([i]);
		}
		for (var i = 0, j = 3 + header[2]; i < header[2]; i++) {
			state.dict.push(header.slice(j, j + header[i + 3]));
			j += header[i + 3];
		}
	},
	decodeStart: function(state, header) {
		state.buffer = [];
	},
	decodeStep: function(input, state) {
		if (state.buffer.length == 0) {
			var b = input.next();
			if (b.done) return state.sym1;
			state.buffer = Array.from(state.dict[b.value[1]]);
		}
		return state.buffer.shift();
	}
};
//	Helper functions -- suffix array, original by Thomas Switzer (tixxit)
function codecDictBSort(a, key) {
	var len = a.length,
		buckets = [],
		i = len, j = -1, b, d = 0,
		keys = 0,
		bits;
	key = key || (function(x) { return x; });
	while (i--)
		j = Math.max(key(a[i]), j);
	bits = j >> 24 && 32 || j >> 16 && 24 || j >> 8 && 16 || 8;
	for (; d < bits; d += 4) {
		for (i = 16; i--;)
			buckets[i] = [];
		for (i = len; i--;)
			buckets[(key(a[i]) >> d) & 15].push(a[i]);
		for (b = 0; b < 16; b++)
			for (j = buckets[b].length; j--;)
				a[++i] = buckets[b][j];
	}
	return a;
}
function codecDictSuffixArray(s, len) {
	var a = [],
		b = [],
		alen = Math.floor(2 * len / 3),		// Number of indexes such that i % 3 != 0
		blen = len - alen,					// " " "  i % 3 == 0
		r = (alen + 1) >> 1,				// " " "  i % 3 == 1
		i = alen,
		j = 0,
		k,
		lookup = [],
		result = [],
		tmp, cmp;

	if (len == 1)
		return [ 0 ];

	// Sort suffixes w/ indices % 3 != 0 by their first 3 symbols (triplets).
	while (i--)
		a[i] = ((i * 3) >> 1) + 1;	// a = [1, 2, 4, 5, 7, 8, 10, 11, 13, ...]

	for (i = 3; i--;)
		codecDictBSort(a, function(j) { return s[i + j] });

	// Assign lexicographical names (j) to the triplets of consecutive symbols,
	// s.t. the order of the lex. names match the lex. order of the triplets.

	// Array b contains lex. names in the order they appear in s for i % 3 != 0
	j = b[Math.floor(a[0] / 3) + (a[0] % 3 == 1 ? 0 : r)] = 1;
	for (i = 1; i < alen; i++) {
		if (s[a[i]] != s[a[i-1]] || s[a[i] + 1] != s[a[i-1] + 1] || s[a[i] + 2] != s[a[i-1] + 2])
			j++;
		b[Math.floor(a[i] / 3) + (a[i] % 3 == 1 ? 0 : r)] = j;
	}

	// If all lex. names are unique, then a is already completely sorted.
	if (j < alen) {

		// Otherwise, recursively sort lex. names in b, then reconstruct the
		// indexes of the sorted array b so they are relative to a.
		b = codecDictSuffixArray(b, alen);

		for (i = alen; i--;)
			a[i] = b[i] < r ? b[i] * 3 + 1 : ((b[i] - r) * 3 + 2);

	}

	// Create a reverse lookup table for the indexes i, s.t. i % 3 != 0.
	// This table can be used to simply determine the sorted order of 2
	// suffixes whose indexes are both not divisible by 3.
	for (i = alen; i--;)
		lookup[a[i]] = i;
	lookup[len] = -1;
	lookup[len + 1] = -2;

	/**
	 * This is a comparison function for the suffixes at indices m & n that
	 * uses the lookup table to shorten the searches. It assumes that
	 * n % 3 == 0 and m % 3 != 0.
	 */
	cmp = function(m, n) {
		return (s[m] - s[n]) || (m % 3 == 2
			? (s[m + 1] - s[n + 1]) || (lookup[m + 2] - lookup[n + 2])
			: (lookup[m + 1] - lookup[n + 1]))
	};

	// Sort remaining suffixes (i % 3 == 0) using prev result (i % 3 != 0).
	b = len % 3 == 1 ? [len - 1] : [];
	for (i = 0; i < alen; i++)
		if (a[i] % 3 == 1)
			b.push(a[i] - 1);
	codecDictBSort(b, function(j) { return s[j] });

	// Merge a (i % 3 != 0) and b (i % 3 == 0) together. We only need to
	// compare, at most, 2 symbols before we end up comparing 2 suffixes whose
	// indices are both not divisible by 3. At this point, we can use the
	// reverse lookup array to order them.
	for (i = 0, j = 0, k = 0; i < alen && j < blen;)
		result[k++] = cmp(a[i], b[j]) < 0 ? a[i++] : b[j++];
	while (i < alen)
		result[k++] = a[i++];
	while (j < blen)
		result[k++] = b[j++];

	return result;
}
//	See https://www.geeksforgeeks.org/largest-rectangle-under-histogram/
function codecDictMaxHistogram(row) {
	var stack = [];
	var bestRun = {row: 0, height: 0, width: 0, cnt: 1};
	var height, y;
	for (y = 0; y < row.length;) {
		if (stack.length == 0 || row[stack[stack.length - 1]] <= row[y]) {
			stack.push(y++);
		} else {
			var top = stack.pop();
			if (stack.length == 0) {
				//	if stack is empty means everything till y has to be
				//	greater or equal to row[top] so get area by
				//	row[top] * y;
				height = y;
			} else {
				//	if stack is not empty then everything from y-1 to row.peek() + 1
				//	has to be greater or equal to row[top]
				//	so area = row[top] * (y - stack.peek() - 1);
				height = (y - stack[stack.length - 1] - 1);
			}
			//var cnt = row[top] * height;	//	By area
			var cnt = row[top] * (height + 1) / (row[top] + height + 2);	//	By compression rate
			if (cnt > bestRun.cnt && row[top] > 1) {	//	Save new best values
				bestRun.width = row[top];
				bestRun.cnt = cnt;
				bestRun.row = y - height;
				bestRun.height = height;
			}
		}
	}
	//	Clean out what's left on the stack, in case it may be better -- same process
	while (stack.length > 0) {
		var top = stack.pop();
		if (stack.length == 0) {
			height = y;
		} else {
			height = (y - stack[stack.length - 1] - 1);
		}
			var cnt = row[top] * (height + 1) / (row[top] + height + 2);
		if (cnt > bestRun.cnt && row[top] > 1) {
			bestRun.width = row[top];
			bestRun.cnt = cnt;
			bestRun.row = y - height;
			bestRun.height = height;
		}
	}
	return bestRun;
}
function codecDictTranslateWordsGreedy(dict, blocks) {
	var outbuf = []; outbuf.length = blocks.length;
	outbuf.use = []; outbuf.use.length = dict.length;
	for (var i = 0; i < dict.length; i++) outbuf.use[i] = 0;
	for (var i = 0; i < blocks.length; i++) {
		outbuf[i] = [];
		var pos = 0;
		while (pos < blocks[i].length) {
			//	TODO: replace with sorted dictionary and binary search
			var width = 0, word = 0;
			for (var d = dict.syms; d < dict.length; d++) {
				/*
				var w = codecDictArrayMatch(blocks[i].slice(pos), dict[d]);
				//	unsorted dict
				if (w > width) {
					width = w; word = d;
				}
				*/
				//	sorted dict
				width = codecDictArrayMatch(blocks[i].slice(pos), dict[d]);
				if (width > 1) {
					word = d;
					break;
				}
			}
			if (width == 0) {
				//	Not found in dictionary, force implicit output
				width = 1; word = blocks[i][pos];
			}
			pos += width; outbuf[i].push(word); outbuf.use[word]++;
		}
	}
	return outbuf;
}
function codecDictTranslateWordsDynprog(dict, blocks) {

	const TEST_WORDS = 3;		//	Number of words to test

	var outbuf = []; outbuf.length = blocks.length;
	outbuf.use = []; outbuf.use.length = dict.length;
	for (var i = 0; i < dict.length; i++) outbuf.use[i] = 0;
	for (var i = 0; i < blocks.length; i++) {
		var totalLength = 0;
		outbuf[i] = [];
		do {
			var w = findBestPrefixWord(dict, blocks[i], totalLength, TEST_WORDS).word;
			outbuf[i].push(w);
			outbuf.use[w]++;
			totalLength += dict[w].length;
		} while (totalLength < blocks[i].length);
	}
	return outbuf;
/*
FontLucidiaBoldNumbers.png
Prior version, greedy translation with dictionary pruning (bytes):
Rows: 1251, Blocks, row: 1448, Blocks, col: 1352

Greedy without dict pruning (remove zeroes only):
Rows: 1735, Blocks, row: 2169, Blocks, col: 2021

Dyn without pruning (default 4 words tested):
Rows: 1735, Blocks, row: 2162, Blocks, col: 2034

Dyn with pruning:
Rows: 1229, Blocks, row: 1426, Blocks, col: 1263

Dyn with pruning, 5 word testing:
Rows: 1229, Blocks, row: 1426, Blocks, col: 1256

Dyn with pruning, 6 word testing:
Rows: 1229, Blocks, row: 1426, Blocks, col: 1256

Dyn with pruning, 3 word testing:
Rows: 1229, Blocks, row: 1426, Blocks, col: 1276

Dyn with pruning, 2 word testing:
Rows: 1230, Blocks, row: 1443, Blocks, col: 1298

Dyn, 5 words, pruning poorly used words (leaving unused until cleanup):
Rows: 1238, Blocks, row: 1246, Blocks, col: 1142

Dyn, 3 words, pruning poorly used words (leaving unused until cleanup):
Rows: 1236, Blocks, row: 1250, Blocks, col: 1172

Dyn, 3 words, entropy based word length limit, pruning poorly used words (leaving unused until cleanup):
Rows: 1182, Blocks, row: 1143, Blocks, col: 1080

Greedy, 1.5x word length limit, pruning poorly used words (leaving unused until cleanup):
Rows: 1172, Blocks, row: 1164, Blocks, col: 1084
*/
	function findBestPrefixWord(dict, block, start, words) {
		//	Try all combinations of words, matching from block[start] onward,
		//	and return the first word of the combination which covers the
		//	most total symbols, or which fills the block, from start to
		//	block.length - 1, using the fewest words

		var best = {word: 0, len: 0, unused: 0};
		var f;
		//	Easy out: it's already done
		if (start >= block.length || words == 0) {
			return best;
		}
		//	Also easy out, if there's only one symbol remaining: use trivial word
		if (start == block.length - 1) {
			best.word = block[start]; best.len = 1; best.unused = words - 1;
			return best;
		}
		//	Find all matching words, longest first
		//	(dict is sorted by length, except for trivial words at the start, skip over them)
		var s = block.slice(start);
		for (var i = dict.findIndex(a => a.length > 1); i < dict.length; i++) {
			if (codecDictArrayMatch(s, dict[i])) {
				if (words == 1 || start + dict[i].length == block.length) {
					//	Used all words, or exact fit -- we're done
					best.word = i; best.len = dict[i].length; best.unused = words - 1;
					return best;
				}
				f = findBestPrefixWord(dict, block, start + dict[i].length, words - 1);
				f.len += dict[i].length;
				if (f.len > best.len || f.unused > best.unused) {
					best.word = i; best.len = f.len; best.unused = f.unused;
				}
			}
		}
		//	Finally, check trivial word
		f = findBestPrefixWord(dict, block, start + 1, words - 1);
		if (f.len + 1 > best.len || f.unused > best.unused) {
			best.word = block[start]; best.len = f.len + 1; best.unused = f.unused;
		}
		return best;
	}
}
function codecDictArrayMatch(block, word) {
	if (block.length < word.length) return 0;
	for (var i = 0; i < word.length; i++) {
		if (block[i] != word[i]) return 0;
	}
	return word.length;
}
function codecDictArrayCompare(a, b) {
	for (var d, i = 0; i < a.length && i < b.length && !d; i++)
		d = a[i] - b[i];
	return d || (a.length - b.length);
}


//	Copy to add more codecs
/**	foo  */
/*
{
	id: 0x375c,
	name: 'Foo Bar',
	encodeInit: function(state, symbols) {
		return;
	},
	encodeStart: function(state, symbols) {
		return;
	},
	encodeStep: function(input, state, output) {
		output.push(input);
	},
	encodeEnd: function(state, output) {
		return;
	},
	encodeFinal: function(state) {
		var h = [];
		return h;
	},
	decodeInit: function(state, header) {
		return;
	},
	decodeStart: function(state, header) {
		return;
	},
	decodeStep: function(input, state) {
		return input.next().value[1];
	}
}
*/

//	Add all codecs to this array:
const ALL_CODECS = [
	codecNothing,
	codecNibble,
	codecHuffman,
	codecArithD,
	codecArithFixed,
	codecArithAdapt,
	codecRLE,
	codecDict,
];

	--></script>
  </body>
</html>
